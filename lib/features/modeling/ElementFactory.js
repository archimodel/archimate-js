import {
  assign,
  forEach
} from 'min-dash';

import inherits from 'inherits-browser';

import {
  getLayerType,
  getAspectType,
  getTypeName,
  NOTE,
  NODE_ELEMENT,
  CONNECTION_RELATIONSHIP,
  CONNECTION_LINE
} from '../../util/ModelUtil';

import BaseElementFactory from 'diagram-js/lib/core/ElementFactory';

import { serializeStyle } from './cmd/UpdateStyleHandler';

import {
  DEFAULT_LABEL_SIZE
} from '../../util/LabelUtil';

import { logger } from "../../util/Logger";

import { toHex, DEFAULT_NOTE_COLOR, BLACK_SHADOW, COLOR_LAYER_MAP, DEFAULT_CONNECTION_COLOR } from '../../util/ColorUtil';
import { BLACK_RGBA, LINEWIDTH_NORMAL } from '../../draw/ArchimateRendererUtil';
import { FONTNAME_DEFAULT, FONTSIZE_DEFAULT } from '../../draw/TextRenderer';
import { ARCHIMATE_CONNECTION, ARCHIMATE_NODE } from '../../metamodel/Concept';

/**
 * An Archimate elements factory for diagram-js shapes
 * 
 * This function get informations from PaletteProvider or ArchimateImporter 
 * in order to create a shape, a connection or a root element to display on canvas.
 * The final rendering is done by ArchimateRenderer in order draw the element.
 * 
 * elementType (String) can be : root, shape or label
 * attrs contains :
 * => called from ArchimateImporter
 *   - businessObject (Archimate element description from XML Archimate model => Moddle)
 *   - bounds of the shape (height, width, x, y)
 *   - hidden
 *   - isFrame (boolean)
 *   - type of the element to draw and passed to ArchimateRenderer (ex. BusinessActor)
 * 
 *   => called from PaletteProvider
 *    - only type property 
 *    In this case, 'create' function calls ArchimateFactory create function in order 
 *    to get back two Moddle objects for elementRef and viewElement 
 * 
 * At the end, basecreate (inherits from BaseElementFactory) is calling with elementType and attrs.
 * This function callback drawShape function in ArchimateRenderer.
 * 
 */
export default function ElementFactory(archimateFactory, moddle, translate) {
  BaseElementFactory.call(this);

  this._archimateFactory = archimateFactory;
  this._moddle = moddle;
  this._translate = translate;
}

inherits(ElementFactory, BaseElementFactory);

ElementFactory.$inject = [
  'archimateFactory',
  'moddle',
  'translate'
];

ElementFactory.prototype.baseCreate = BaseElementFactory.prototype.create;


/*

*/
ElementFactory.prototype.create = function(elementType, attrs) {

  logger.log('create(elementType, attrs)');
  logger.log({elementType, ...attrs});

  // no special magic for labels,
  // we assume their businessObjects have already been created
  // and wired via attrs
  if (elementType === 'label') {
    logger.log('create label element');
    return this.baseCreate(elementType, assign({ type: 'label' }, DEFAULT_LABEL_SIZE, attrs));
  }

  if (elementType === 'connection') {
    return this.createConnection(attrs);
  }
}

ElementFactory.prototype.createRoot = function(attrs) {

  logger.log('create root element');

  var view = attrs.businessObject;

  attrs = assign({
    id: view.id,
    type: 'root'
  }, attrs);

  return this.baseCreate('root', attrs);
}

ElementFactory.prototype.createConnection = function(attrs) {
  logger.log('create connection element');
  logger.log(attrs);

  var translate = this._translate;

  // get the Archimate Connection element attached to the archimate view
  var archimateConnection = attrs.businessObject,
    type = attrs.type;

  if (!type) {
    throw new Error(translate('no relationship type specified'));
    // attrs.type = 'Association';
  }

  // init connection attributes with args
  var connectionAttrs = {
    type: type,
    source: attrs.source,
    target: attrs.target,
    waypoints: attrs.waypoints
  }

  var style = {};

  if (archimateConnection) {
    // get all attrs needed for rendering from archimateConnection generated by importer
    logger.log(archimateConnection);

    // get style
    if (archimateConnection.style) {
      style = serializeStyle(archimateConnection.style);
    }

    assign(connectionAttrs, {
      businessObject: archimateConnection,
      text: archimateConnection.label,
      id: archimateConnection.id,
      style: style
    });

    // get attrs from relationshipRef
    setAttrsRelationshipRef(connectionAttrs, archimateConnection.relationshipRef);

  } else {
    // this is a new connection to draw on canvas, create core businessObject
    // other attrs (eg. relationshipRef) will be set in CreateElementBehavior
    // based on attrs directly set on connection element

    if (type === 'Line') {
      archimateConnection = this._archimateFactory.create(ARCHIMATE_CONNECTION, { type: CONNECTION_LINE });
      assign(style, {
        lineColor: BLACK_SHADOW,
        lineWidth: 1
      });

    } else {
      archimateConnection = this._archimateFactory.create(ARCHIMATE_CONNECTION, { type: CONNECTION_RELATIONSHIP });
       assign(style, {
        lineColor: DEFAULT_CONNECTION_COLOR,
        lineWidth: 1
      });

      assign(connectionAttrs, {
        name: '',
      });

    }

    // this is a special case when a neeested connection need to be 
    // create after moving shape
    if (attrs.relationshipRef) {
      archimateConnection.relationshipRef = attrs.relationshipRef
      setAttrsRelationshipRef(connectionAttrs, attrs.relationshipRef)
    }

    assign(connectionAttrs, {
      businessObject: archimateConnection,
      id: archimateConnection.id,
      style: style,
    });
  }

  logger.log('call baseCreate for getting a connection element with attrs:');
  logger.log(connectionAttrs);

  var newConnection = this.baseCreate('connection', connectionAttrs);

  logger.log(newConnection);

  return newConnection;

}

ElementFactory.prototype.createShape = function(attrs) {
  logger.log('create shape element');

  var translate = this._translate;

  attrs = attrs || {};

  if (!attrs.type) {
    throw new Error(translate('no base element type specified'));
  }

  // get the Archimate Node element attached to the archimate view
  var archimateNode = attrs.businessObject;

  var style = {};
  
  if (archimateNode) {
    // get all attrs needed for rendering from archimateNode generated by importer
    logger.log(archimateNode);

    if(attrs.type !== NOTE) {
      attrs = assign({
        name: archimateNode.elementRef && archimateNode.elementRef.name,
        layer: getLayerType(attrs.type),
        aspect: getAspectType(attrs.type),
      }, attrs);
    }

    // get style
    if (archimateNode.style) {
      style = serializeStyle(archimateNode.style);
    }

    attrs = assign({
      style: style,
      text: archimateNode.label,
      id: archimateNode.id
    }, attrs);



  } else {
    // this is a new shape to draw on canvas, create core businessObject
    // if no business Object, rendering shape is not call 
    // other attrs (eg. elementRef) will be set in CreateElementBehavior
    // based on attrs directly set on shape element

    if (attrs.type === NOTE) {
      archimateNode = this._archimateFactory.create(ARCHIMATE_NODE, { type: NOTE, label: '' });

      // set default style for Note
      assign(style, {
        fillColor: DEFAULT_NOTE_COLOR,
        lineColor: BLACK_SHADOW,
        textAlignment: 'left',
        textPosition: 'top'
      });

      attrs = assign({
        text: '',
      }, attrs);

    } else {
      
      archimateNode = this._archimateFactory.create(ARCHIMATE_NODE, { type: NODE_ELEMENT });

      var layer = getLayerType(attrs.type);

      // set default style for Archimate Element
      assign(style, {
        fillColor: COLOR_LAYER_MAP.get(layer),
        lineColor: BLACK_SHADOW,
        textAlignment: 'center',
        textPosition: 'middle'
      });
      
      attrs = assign({
        name: getTypeName(attrs.type),
        layer: layer,
        aspect: getAspectType(attrs.type),
      }, attrs);

    }

    var size = this._getDefaultSize(attrs.type);

    attrs = assign({
      style: style,
      businessObject: archimateNode,
      id: archimateNode && archimateNode.id,
    }, size, attrs);  // => size's values are overided if attrs contains width and height properties (eg. when attrs object comes from ArchimateFactory)
  }

  logger.log('call baseCreate with :');
  logger.log({attrs});

  var newShape = this.baseCreate('shape', attrs);

  logger.log(newShape);

  return newShape;
}

/*
    if (is(elementRef, 'archimate:Group')) {
      attrs = assign({
        isFrame: true
      }, attrs);
    }
*/

ElementFactory.prototype._getDefaultSize = function(elementType) {
  if (elementType === 'archimate:Group') {
    return { width: 300, height: 300 };
  }

  if (elementType === NOTE) {
    // return { width: 150, height: 80 };
  }

  return { width: 120, height: 55 };
};

// helpers //////////////////////

// setting attrs from relationshipRef
function setAttrsRelationshipRef(attrs, relationshipRef) {

  assign(attrs, {
    name: relationshipRef && relationshipRef.name,
  });

  if (attrs.type === 'Access') {
    assign(attrs, {
      typeOption: relationshipRef && relationshipRef.accessType
    });
  }

  if (attrs.type === 'Association') {
    assign(attrs, {
      typeOption: relationshipRef && relationshipRef.isDirected
    });
  }

  if (attrs.type === 'Influence') {
    assign(attrs, {
      typeOption: relationshipRef && relationshipRef.modifier
    });
  }
}


/**
 * Apply attributes from a map to the given element,
 * remove attribute from the map on application.
 *
 * @param {Base} element
 * @param {Object} attrs (in/out map of attributes)
 * @param {Array<String>} attributeNames name of attributes to apply
 */
function applyAttributes(element, attrs, attributeNames) {

  forEach(attributeNames, function(property) {
    if (attrs[property] !== undefined) {
      applyAttribute(element, attrs, property);
    }
  });
}

/**
 * Apply named property to element and drain it from the attrs
 * collection.
 *
 * @param {Base} element
 * @param {Object} attrs (in/out map of attributes)
 * @param {String} attributeName to apply
 */
function applyAttribute(element, attrs, attributeName) {
  element[attributeName] = attrs[attributeName];

  delete attrs[attributeName];
}